如何支持c++和函数统计

c++由于具有面向对象的特性，在继承的时候会引起各种多态，这将导致静态分析的时候难以唯一确定某个实例方法实际在运行时调用的是哪个方法；除此之外，函数指针机制允许通过指针来完成过程调用，这种机制导致静态分析的时候无法唯一确定函数指针所指向的函数对象，这些都是在静态分析的时候构建c++函数调用图的难点。但是，目前函数调用图的构建是基于LLVMIR的，在IR层面上已经没有了面向对象的机制，函数调用的时候也没有多态的特性，每一个显式调用的函数都是可以唯一确定的，这样就解决了第一个问题；函数指针的处理可以参见DSA部分。因此，基于目前构建函数调用图的方案构建c++的函数调用图的主要工作，就是找到IR中函数名称同被分析源代码中函数名称的对应关系，这涉及到c++函数的name mangling机制。

name mangling是c++（c）编译器在编译时对函数名称的一种转化机制。具体而言，函数名称的转化机制大致如下：
类中的成员函数名的转换方式为：_ZN/_ZZ + (namespacelength + namespace)* + methodnamelength + methodname + (C/D + number)? + E + v/i/c...
    _ZN是前缀，'N'用于成员函数，'_ZZ'用于声明为const的函数
    namespacelength是函数所在命名空间的名字长度
    namespace是函数所在命名空间的名字
    namespacelength和namespace可以有多层
    methodnamelength是方法名长度
    methodname是方法名
    C/D + number C表示构造函数，D表示析构函数，number表示不同类型的构造或析构函数，如C1表示complete object constructor，C2表示base object constructor等。
E后面的符号表示函数的参数类型，如v表示void，ic表示第一个参数为int、第二个参数为char，等等。
举例而言的话，_ZN1A6PrintAEv对应的函数名称就是A::PrintA()。这样，只要找到IR中当前调用函数的名称，根据翻译规则将当前的函数名称还原，就可以在构建函数调用图的时候清晰地显示出函数调用的关系。一般地，如果想要方便地根据IR中的函数名称还原原函数名，可以使用c++filt工具；在构建函数调用图的时候，则可以使用<cxxabi.h>所提供的函数__cxa_demangle，这个函数接受一个指向IR中函数名称的字符型指针，并返回一个指向翻译后函数名称的指针，这样就可以方便地完成函数名称的还原，省去了手工编写翻译函数的麻烦。

剩下的部分主要就是一些工程实现上的问题。在原来函数调用图的实现中，所有的函数名都用手工编写的翻译函数统一转化成标准的函数名称再进行比较和分析，但是在构建c++函数调用图的时候会遇到一些麻烦：因为类似_ZN2B1C2Ev和_ZN2B1C1Ev翻译得到的原函数名都是B1::B1()，但是比较的时候显然不能把他们当成同一个函数；另外，在生成graphviz结点的时候，翻译得到的函数名B1::B1()也不能够当做结点名称（结点名称不能含有括号）。这里，比较好的方式是在比较函数和生成结点的时候都采用IR中的函数名，只有生成结点标签信息的时候才使用原函数名，因此需要对原来的实现方案做相应的调整。在指定分析的根节点函数时，由于用户输入的是原函数名，应此也需要将这个函数名转化成IR中的函数名，再调用分析函数。

实现函数统计则相对要更为简单。由于在IR中，每一个函数所调用的函数经过一遍扫描都是可以唯一确定的，因此统计函数调用次数时只需要在分析的时候，每次遇到指定函数的调用的时候将计数变量加一，最后输出总的计数次数即可；在原来的实现中getCountofCallInst已经实现了一个类似的机制。这里有一个问题，如果遇到递归调用的情况，没有办法实现精确的统计，这一点在静态分析的时候也确实很难做到；在原来的实现中，也只是简单地将这种情况标注为有递归，而没有去具体地进行更细致的分析。